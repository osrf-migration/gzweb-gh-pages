{"links": {"self": {"href": "data/repositories/osrf/gzweb/issues/85/comments/49350455.json"}, "html": {"href": "#!/osrf/gzweb/issues/85#comment-49350455"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/gzweb/issues/85.json"}}, "type": "issue", "id": 85, "repository": {"links": {"self": {"href": "data/repositories/osrf/gzweb.json"}, "html": {"href": "#!/osrf/gzweb"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3e2fc3f2-dc25-453b-9792-943c743d9b40}ts=1609263"}}, "type": "repository", "name": "gzweb", "full_name": "osrf/gzweb", "uuid": "{3e2fc3f2-dc25-453b-9792-943c743d9b40}"}, "title": "laser visualization for hokuyo type sensors not appearing"}, "content": {"raw": "Here're a list of things to do that  I can think off to get something working quickly\n\nServer-side: \n\n* instead of just [forwarding model msgs](#!/osrf/gzweb/src/4742f7054553e5818edd9194b4f969bbdf031a7f/gzbridge/GazeboInterface.cc#lines-751) to the frontend, we need to loop through it's links and look for sensors. If it's a ray sensor, instantiate a new subscriber that subscribes to the laser topic\n\n* Store these laser msgs like how it's done for others, e.g.  similar to this [function](#!/osrf/gzweb/src/4742f7054553e5818edd9194b4f969bbdf031a7f/gzbridge/GazeboInterface.cc#lines-888)\n\n*  Forward the msgs to the front-end, e.g. [pack and send them](#!/osrf/gzweb/src/4742f7054553e5818edd9194b4f969bbdf031a7f/gzbridge/GazeboInterface.cc#lines-751)\n\nOnce that's done, we need to visualize the data in the browser. Extend gziface.js' `createModelFromMsg` function to parse for sensors. If it's a ray sensor, create a new subscriber to the laser topic. On callback, create and update the laser visuals.  You'll need to a new function in gzscene.js to draw lasers using threejs.", "markup": "markdown", "html": "<p>Here're a list of things to do that  I can think off to get something working quickly</p>\n<p>Server-side: </p>\n<ul>\n<li>\n<p>instead of just <a data-is-external-link=\"true\" href=\"#!/osrf/gzweb/src/4742f7054553e5818edd9194b4f969bbdf031a7f/gzbridge/GazeboInterface.cc#lines-751\" rel=\"nofollow\">forwarding model msgs</a> to the frontend, we need to loop through it's links and look for sensors. If it's a ray sensor, instantiate a new subscriber that subscribes to the laser topic</p>\n</li>\n<li>\n<p>Store these laser msgs like how it's done for others, e.g.  similar to this <a data-is-external-link=\"true\" href=\"#!/osrf/gzweb/src/4742f7054553e5818edd9194b4f969bbdf031a7f/gzbridge/GazeboInterface.cc#lines-888\" rel=\"nofollow\">function</a></p>\n</li>\n<li>\n<p>Forward the msgs to the front-end, e.g. <a data-is-external-link=\"true\" href=\"#!/osrf/gzweb/src/4742f7054553e5818edd9194b4f969bbdf031a7f/gzbridge/GazeboInterface.cc#lines-751\" rel=\"nofollow\">pack and send them</a></p>\n</li>\n</ul>\n<p>Once that's done, we need to visualize the data in the browser. Extend gziface.js' <code>createModelFromMsg</code> function to parse for sensors. If it's a ray sensor, create a new subscriber to the laser topic. On callback, create and update the laser visuals.  You'll need to a new function in gzscene.js to draw lasers using threejs.</p>", "type": "rendered"}, "created_on": "2018-12-07T18:56:31.677824+00:00", "user": {"display_name": "Ian Chen", "uuid": "{eaa6fca5-6deb-43f6-907f-971c144735dd}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beaa6fca5-6deb-43f6-907f-971c144735dd%7D"}, "html": {"href": "https://bitbucket.org/%7Beaa6fca5-6deb-43f6-907f-971c144735dd%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:10b01d41-a2e9-4a41-a907-e6e2f03b6cd5/1e4adcdf-1946-4280-9aea-eb5f15a7f912/128"}}, "nickname": "Ian Chen", "type": "user", "account_id": "557058:10b01d41-a2e9-4a41-a907-e6e2f03b6cd5"}, "updated_on": null, "type": "issue_comment", "id": 49350455}