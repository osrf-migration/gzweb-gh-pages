{"priority": "major", "kind": "bug", "repository": {"links": {"self": {"href": "data/repositories/osrf/gzweb.json"}, "html": {"href": "#!/osrf/gzweb"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3e2fc3f2-dc25-453b-9792-943c743d9b40}ts=1609263"}}, "type": "repository", "name": "gzweb", "full_name": "osrf/gzweb", "uuid": "{3e2fc3f2-dc25-453b-9792-943c743d9b40}"}, "links": {"attachments": {"href": "data/repositories/osrf/gzweb/issues/52/attachments_page=1.json"}, "self": {"href": "data/repositories/osrf/gzweb/issues/52.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gzweb/issues/52/watch"}, "comments": {"href": "data/repositories/osrf/gzweb/issues/52/comments_page=1.json"}, "html": {"href": "#!/osrf/gzweb/issues/52/lights-are-not-updated-when-they-change-on"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gzweb/issues/52/vote"}}, "reporter": {"display_name": "Luc Guyot", "uuid": "{10bf39a6-3a1b-4c7f-9702-fe864c3e8066}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B10bf39a6-3a1b-4c7f-9702-fe864c3e8066%7D"}, "html": {"href": "https://bitbucket.org/%7B10bf39a6-3a1b-4c7f-9702-fe864c3e8066%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:baecfd3c-7ba6-47b5-8711-417af281b471/ed635f95-3d51-407b-b3c0-b20f3d58328a/128"}}, "nickname": "luc_guyot_", "type": "user", "account_id": "557058:baecfd3c-7ba6-47b5-8711-417af281b471"}, "title": "Lights are not updated when they change on the server", "component": null, "votes": 0, "watches": 4, "content": {"raw": "As you can see from this gziface's excerpt, nothing is done when light properties change:\r\n\r\n```\r\n  var lightUpdate = function(message)\r\n  {\r\n    if (!this.scene.getByName(message.name))\r\n    {\r\n      var lightObj = this.createLightFromMsg(message);\r\n      this.scene.add(lightObj);\r\n      guiEvents.emit('notification_popup', message.name+' inserted');\r\n    }\r\n    this.gui.setLightStats(message, 'update');\r\n  };\r\n\r\n  lightTopic.subscribe(lightUpdate.bind(this));\r\n```\r\n\r\nSketch of fix:\r\n```\r\n  var lightUpdate = function(message)\r\n  {\r\n    var entity = this.scene.getByName(message.name);\r\n    if (!entity)\r\n    {\r\n      var lightObj = this.createLightFromMsg(message);\r\n      this.scene.add(lightObj);\r\n      guiEvents.emit('notification_popup', message.name+' inserted');\r\n    } else {\r\n      this.scene.updateLight(entity, message);\r\n    }\r\n    this.gui.setLightStats(message, 'update');\r\n  };\r\n\r\n  lightTopic.subscribe(lightUpdate.bind(this));\r\n```\r\nand \r\n\r\n```\r\nGZ3D.Scene.prototype.updateLight = function(model, light)\r\n{\r\n  var direction, lightType;\r\n  var lightObj = model.children[0];\r\n\r\n  if (this.modelManipulator && this.modelManipulator.object &&\r\n      this.modelManipulator.hovered)\r\n  {\r\n    return;\r\n  }\r\n  \r\n  var matrixWorld;\r\n  if (light.pose) {\r\n    this.setPose(model, light.pose.position, light.pose.orientation);\r\n\r\n    // needed to update light's direction\r\n    model.updateMatrixWorld();\r\n    var quaternion = new THREE.Quaternion(\r\n         light.pose.orientation.x,\r\n         light.pose.orientation.y,\r\n         light.pose.orientation.z,\r\n         light.pose.orientation.w);\r\n \r\n    var translation = new THREE.Vector3(\r\n         light.pose.position.x,\r\n         light.pose.position.y,\r\n         light.pose.position.z);\r\n \r\n    matrixWorld = new THREE.Matrix4();\r\n    matrixWorld.compose(translation, quaternion, new THREE.Vector3(1,1,1));\r\n  }\r\n\r\n  if (lightObj instanceof THREE.PointLight)\r\n  {\r\n    direction = null;\r\n    lightType = this.POINT;\r\n  }\r\n  else if (lightObj instanceof THREE.SpotLight)\r\n  {\r\n    direction = light.direction;\r\n    lightType = this.SPOT;\r\n  }\r\n  else if (lightObj instanceof THREE.DirectionalLight)\r\n  {\r\n    direction = light.direction;\r\n    lightType = this.DIRECTIONAL;\r\n  }\r\n\r\n  if (light.diffuse) {\r\n    var color = new THREE.Color();\r\n\r\n    if (typeof(light.diffuse) === 'undefined')\r\n    {\r\n      light.diffuse = 0xffffff;\r\n    }\r\n    else if (typeof(light.diffuse) !== THREE.Color)\r\n    {\r\n      color.r = light.diffuse.r;\r\n      color.g = light.diffuse.g;\r\n      color.b = light.diffuse.b;\r\n      diffuse = color.clone();\r\n    }\r\n    lightObj.color = light.diffuse;\r\n  }\r\n  if (light.specular) {\r\n    // property not relevant in THREE.js\r\n  }\r\n  if (light.attenuation_constant) {\r\n    lightObj.intensity = this.attenuationToIntensity(light.attenuation_constant, lightType);\r\n  }\r\n  if (light.attenuation_linear) {\r\n    // property not relevant in THREE.js\r\n  }\r\n  if (light.attenuation_quadratic) {\r\n    // property not relevant in THREE.js\r\n  }\r\n  if (light.range) {\r\n    // THREE.js's light distance impacts the attenuation factor defined in the shader: \r\n    // attenuation factor = 1.0 - distance-to-enlighted-point / light.distance\r\n    // Gazebo's range (taken from OGRE 3D API) does not contribute to attenuation; it is a hard limit\r\n    // for light scope.\r\n    // Nevertheless, we identify them for sake of simplicity.\r\n    lightObj.distance = light.range; \r\n  }\r\n  if (lightObj instanceof THREE.SpotLight) {\r\n    if (light.spot_inner_angle) {\r\n      // property not relevant in THREE.js\r\n    }\r\n    if (light.spot_outer_angle) {\r\n      lightObj.angle = light.spot_outer_angle;\r\n    }\r\n    if (light.spot_falloff) {\r\n      lightObj.exponent = light.spot_falloff;\r\n    }\r\n  }\r\n\r\n  if (direction) {\r\n    var dir = new THREE.Vector3(direction.x, direction.y,\r\n        direction.z);\r\n    model.direction.copy(dir);\r\n    dir.applyMatrix4(matrixWorld); // localToWorld\r\n    lightObj.target.position.copy(dir);\r\n  } else if (light.type === this.POINT || light.type === this.SPOT) {\r\n    var dir = new THREE.Vector3(0,0,0);\r\n    dir.copy(model.direction);\r\n    model.localToWorld(dir);\r\n    lightObj.target.position.copy(dir);\r\n  }\r\n};\r\n```", "markup": "markdown", "html": "<p>As you can see from this gziface's excerpt, nothing is done when light properties change:</p>\n<div class=\"codehilite\"><pre><span></span>  var lightUpdate = function(message)\n  {\n    if (!this.scene.getByName(message.name))\n    {\n      var lightObj = this.createLightFromMsg(message);\n      this.scene.add(lightObj);\n      guiEvents.emit(&#39;notification_popup&#39;, message.name+&#39; inserted&#39;);\n    }\n    this.gui.setLightStats(message, &#39;update&#39;);\n  };\n\n  lightTopic.subscribe(lightUpdate.bind(this));\n</pre></div>\n\n\n<p>Sketch of fix:</p>\n<div class=\"codehilite\"><pre><span></span>  var lightUpdate = function(message)\n  {\n    var entity = this.scene.getByName(message.name);\n    if (!entity)\n    {\n      var lightObj = this.createLightFromMsg(message);\n      this.scene.add(lightObj);\n      guiEvents.emit(&#39;notification_popup&#39;, message.name+&#39; inserted&#39;);\n    } else {\n      this.scene.updateLight(entity, message);\n    }\n    this.gui.setLightStats(message, &#39;update&#39;);\n  };\n\n  lightTopic.subscribe(lightUpdate.bind(this));\n</pre></div>\n\n\n<p>and </p>\n<div class=\"codehilite\"><pre><span></span>GZ3D.Scene.prototype.updateLight = function(model, light)\n{\n  var direction, lightType;\n  var lightObj = model.children[0];\n\n  if (this.modelManipulator &amp;&amp; this.modelManipulator.object &amp;&amp;\n      this.modelManipulator.hovered)\n  {\n    return;\n  }\n\n  var matrixWorld;\n  if (light.pose) {\n    this.setPose(model, light.pose.position, light.pose.orientation);\n\n    // needed to update light&#39;s direction\n    model.updateMatrixWorld();\n    var quaternion = new THREE.Quaternion(\n         light.pose.orientation.x,\n         light.pose.orientation.y,\n         light.pose.orientation.z,\n         light.pose.orientation.w);\n\n    var translation = new THREE.Vector3(\n         light.pose.position.x,\n         light.pose.position.y,\n         light.pose.position.z);\n\n    matrixWorld = new THREE.Matrix4();\n    matrixWorld.compose(translation, quaternion, new THREE.Vector3(1,1,1));\n  }\n\n  if (lightObj instanceof THREE.PointLight)\n  {\n    direction = null;\n    lightType = this.POINT;\n  }\n  else if (lightObj instanceof THREE.SpotLight)\n  {\n    direction = light.direction;\n    lightType = this.SPOT;\n  }\n  else if (lightObj instanceof THREE.DirectionalLight)\n  {\n    direction = light.direction;\n    lightType = this.DIRECTIONAL;\n  }\n\n  if (light.diffuse) {\n    var color = new THREE.Color();\n\n    if (typeof(light.diffuse) === &#39;undefined&#39;)\n    {\n      light.diffuse = 0xffffff;\n    }\n    else if (typeof(light.diffuse) !== THREE.Color)\n    {\n      color.r = light.diffuse.r;\n      color.g = light.diffuse.g;\n      color.b = light.diffuse.b;\n      diffuse = color.clone();\n    }\n    lightObj.color = light.diffuse;\n  }\n  if (light.specular) {\n    // property not relevant in THREE.js\n  }\n  if (light.attenuation_constant) {\n    lightObj.intensity = this.attenuationToIntensity(light.attenuation_constant, lightType);\n  }\n  if (light.attenuation_linear) {\n    // property not relevant in THREE.js\n  }\n  if (light.attenuation_quadratic) {\n    // property not relevant in THREE.js\n  }\n  if (light.range) {\n    // THREE.js&#39;s light distance impacts the attenuation factor defined in the shader: \n    // attenuation factor = 1.0 - distance-to-enlighted-point / light.distance\n    // Gazebo&#39;s range (taken from OGRE 3D API) does not contribute to attenuation; it is a hard limit\n    // for light scope.\n    // Nevertheless, we identify them for sake of simplicity.\n    lightObj.distance = light.range; \n  }\n  if (lightObj instanceof THREE.SpotLight) {\n    if (light.spot_inner_angle) {\n      // property not relevant in THREE.js\n    }\n    if (light.spot_outer_angle) {\n      lightObj.angle = light.spot_outer_angle;\n    }\n    if (light.spot_falloff) {\n      lightObj.exponent = light.spot_falloff;\n    }\n  }\n\n  if (direction) {\n    var dir = new THREE.Vector3(direction.x, direction.y,\n        direction.z);\n    model.direction.copy(dir);\n    dir.applyMatrix4(matrixWorld); // localToWorld\n    lightObj.target.position.copy(dir);\n  } else if (light.type === this.POINT || light.type === this.SPOT) {\n    var dir = new THREE.Vector3(0,0,0);\n    dir.copy(model.direction);\n    model.localToWorld(dir);\n    lightObj.target.position.copy(dir);\n  }\n};\n</pre></div>", "type": "rendered"}, "assignee": null, "state": "resolved", "version": null, "edited_on": null, "created_on": "2014-12-10T16:08:21.727493+00:00", "milestone": null, "updated_on": "2014-12-11T02:06:57.051185+00:00", "type": "issue", "id": 52}